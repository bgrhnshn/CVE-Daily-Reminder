import https from 'https';

import { createGunzip } from 'zlib';

export const handler = (event) => {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);

  const formatDate = (date) => {
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}T00:00:00.000`;
  };


  const sendToSlack = (text) => {


    const slackPayload = {
      text: text
    };

    const options = {
      hostname: 'hooks.slack.com',
      path: process.env.SLACK_WEBHOOK_PATH, // Replace with your actual Slack Webhook path
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let response = '';
      res.on('data', (chunk) => {
        response += chunk;
      });
      res.on('end', () => {
        console.log('Slack responded with:', response);
      });
    });

    req.on('error', (error) => {
      console.error('Error sending to Slack:', error);
    });

    console.log((slackPayload));
    req.write(JSON.stringify(slackPayload));
    req.end();


  };

  const getFirstSentence = (text) => {
    const match = text.match(/(.*?[.!?])\s/);
    return match ? match[1] : text.split('.')[0] + '.';
  };


  const pubStartDate = formatDate(yesterday);
  const pubEndDate = formatDate(today);

  const CVEURL = `https://services.nvd.nist.gov/rest/json/cves/2.0/?pubStartDate=${pubStartDate}&pubEndDate=${pubEndDate}&resultsPerPage=2000`;

  return new Promise((resolve, reject) => {
    https.get(CVEURL, (res) => {
      const gzip = /^gzip/i.test(res.headers['content-encoding']);
      let output;
      if (gzip) {
        output = createGunzip();
        res.pipe(output);
      } else {
        output = res;
      }

      let data = '';

      output.on('data', (chunk) => {
        data += chunk;
      });

      output.on('end', () => {
        const jsonData = JSON.parse(data);

        if (jsonData.vulnerabilities && Array.isArray(jsonData.vulnerabilities)) {
          const extractedData = jsonData.vulnerabilities.map(cveObj => {
            const { id, vulnStatus, descriptions, references, metrics } = cveObj.cve;
            const description = descriptions.find(desc => desc.lang === "en")?.value || 'Description not available';
            const baseScore = metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore;
            const baseSeverity = metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity;
            if (baseScore && baseSeverity) {
              return {
                cveId: id,
                vulnStatus: vulnStatus,
                description: description,
                baseScore: baseScore,
                baseSeverity: baseSeverity,
                references: references.map(ref => ref.url),
              };

            }
            return null;
          }).filter(item => item);
          const highAndCritical = extractedData.filter(item =>
            item.baseSeverity === 'HIGH' || item.baseSeverity === 'CRITICAL');

          highAndCritical.forEach(item => {

            let text = '';
            const firstSentence = getFirstSentence(item.description);
            text += `:large_red_square: *CVE ID*: ${item.cveId}\n*Base Score*: ${item.baseScore}\n*Base Severity*: ${item.baseSeverity}\n*Description*: ${firstSentence}\n*References*: ${item.references.join(', ').substring(0, 3000)}\n\n`;

            sendToSlack(text);

          });
        }

      });
    });
  });
}
